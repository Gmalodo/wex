#!/usr/bin/env bash

# Init only once.
if [ -z "${WEX_INIT:+x}" ];then
  WEX_INIT=true
  . /opt/wex/project/bash/globals.sh

  # Check bash version.
  if [ -z ${WEX_BASH_VERSION+x} ]; then
    WEX_BASH_VERSION_MIN='4'
    WEX_BASH_VERSION=$(sed -n "s/\([[:digit:]]\{0,\}\)\([\.].\{0,\}\)/\1/p" <<< ${BASH_VERSION})
    if [ ${WEX_BASH_VERSION} -lt ${WEX_BASH_VERSION_MIN} ]; then
      echo "Wex error, need to run on bash version "${WEX_BASH_VERSION_MIN}
      exit
    fi;
  fi;

  wexError() {
    . ${WEX_DIR_BASH}/colors.sh
    printf "${WEX_COLOR_RED}[wex] Error : ${1}${WEX_COLOR_RESET}\n"

    # Complementary information or description for extra text
    if [ "${2}" != "" ];then
      printf "      ${WEX_COLOR_CYAN}${2}${WEX_COLOR_RESET}\n"
    fi

    # Extra text
    if [ "${3}" != "" ];then
      printf "      ${3}\n"
    fi
  }

  wexUpperCaseFirstLetter() {
    echo $(tr '[:lower:]' '[:upper:]' <<< ${1:0:1})${1:1}
  }

  wexMethodName() {
    local SPLIT=(${1//// })
    echo ${SPLIT[0]}$(wexUpperCaseFirstLetter ${SPLIT[1]})
  }

  wex() {
    # Using false as argument allow to protect unexpected argument passing
    if [ -z "${1+x}" ] || [ "${1}" == '' ] || [ ${1} == false ]; then
      return;
    fi;

    local WEX_SCRIPT_CALL_NAME=${1}
    local WEX_SCRIPT_FOUND=false
    local WEX_NAMESPACE=${WEX_NAMESPACE_DEFAULT}

    _wex_find_namespace ${WEX_SCRIPT_CALL_NAME}

    WEX_SCRIPT_DIR=${WEX_DIR_BASH}${WEX_NAMESPACE_TEST}/${WEX_SCRIPT_CALL_NAME}
    WEX_SCRIPT_FILE=${WEX_SCRIPT_DIR}.sh

    # Use main script if still not exists.
    if [ -f ${WEX_SCRIPT_FILE} ] || [ -d ${WEX_SCRIPT_DIR} ]; then
      WEX_NAMESPACE=${WEX_NAMESPACE_TEST}
    else
      WEX_NAMESPACE=${WEX_NAMESPACE_DEFAULT}
      # Search into wexample local folder.
      WEX_SCRIPT_FILE=${WEX_DIR_BASH}${WEX_NAMESPACE_DEFAULT}/${WEX_SCRIPT_CALL_NAME}.sh
    fi;

    # Load namespace init file.
    . "${WEX_DIR_BASH}${WEX_NAMESPACE}/init.sh"

    WEX_SCRIPT_METHOD_NAME=$(wexMethodName ${WEX_SCRIPT_CALL_NAME})

    # File does not exists.
    if [ ! -f ${WEX_SCRIPT_FILE} ]; then
      # Show hi
      if [ ${WEX_SCRIPT_CALL_NAME} == "hi" ]; then
        . ${WEX_DIR_BASH}/colors.sh
        printf ". ${WEX_COLOR_YELLOW}★${WEX_COLOR_CYAN}hi${WEX_COLOR_RESET} ${WEX_COLOR_YELLOW}★${WEX_COLOR_RESET}.\n"

      # Show completion
      elif [ -d ${WEX_DIR_BASH}${WEX_NAMESPACE}"/"${WEX_SCRIPT_CALL_NAME} ];then
        local GROUP=$(basename ${WEX_DIR_BASH}${WEX_NAMESPACE}"/"${WEX_SCRIPT_CALL_NAME})
        local NAMESPACES=($(ls ${WEX_DIR_BASH}))

        local PADDING=50
        local PATH_TITLE='Path'
        local DESCRIPTION_TITLE='Description'

        # Prints titles
        echo -n '  '${PATH_TITLE};
        # Prints 50 spaces in order to align title with descriptions
        printf %"$(( ${PADDING} - ${#PATH_TITLE} ))"s
        echo "Description"

        #Prints dashes
        echo -n '  '
        printf %"${#PATH_TITLE}"s |tr " " "-"
        printf %"$(( PADDING - ${#PATH_TITLE}))"s
        printf %"${#DESCRIPTION_TITLE}"s |tr " " "-"
        echo '';

        for NAMESPACE in "${NAMESPACES[@]}"
        do
          local DIR=${WEX_DIR_BASH}${NAMESPACE}"/"${GROUP}

          if [ -d ${DIR} ] && [ -d ${WEX_DIR_BASH}${NAMESPACE} ]; then
            local METHODS=($(ls ${DIR}))
            local GROUP=$(basename ${DIR})

            echo ""

            for FILE in "${METHODS[@]}"
            do
              # Load the file to get command description
              . "${DIR}"/"$FILE"

              # Init empty var.
              local _ARGUMENTS=()
              local _DESCRIPTION=""

              local ARGS_METHOD=${GROUP}$(wexUpperCaseFirstLetter ${FILE%.*})Args
              if [[ $(type -t "${ARGS_METHOD}" 2>/dev/null) == function ]]; then
                # Execute command
                ${ARGS_METHOD}
              fi;

              _COMMAND_PATH=${NAMESPACE}"::"${GROUP}"/${FILE%.*}"
              echo -n "  "${_COMMAND_PATH}

              # If there is a description we show it at 50 characters from the very left
              if [[ "${_DESCRIPTION}" != "" ]]; then
                # Prints a calculated number of spaces in order to align descriptions
                printf %"$(( ${PADDING}-${#_COMMAND_PATH} ))"s

                # Prints the description
                wex text/color -c=lightblue -t="${_DESCRIPTION}"
              else
                echo "";
              fi

            done
          fi
        done

      # Not found.
      else

        # Script not found in main core.
        if [ ${WEX_SCRIPT_FOUND} == false ];then
          local WEX_EXTEND_DIRS=$(ls ${WEX_DIR_EXTEND})

          # Search into extend directories.
          for WEX_EXTEND_DIR in ${WEX_EXTEND_DIRS[@]}
          do
            . ${WEX_DIR_EXTEND}${WEX_EXTEND_DIR}/run.sh

            # No reason to continue seeking for a script.
            if [ ${WEX_SCRIPT_FOUND} == true ];then
              return;
            fi;
          done;
        fi

        if [ ${WEX_SCRIPT_FOUND} == false ];then
          WEX_TEST_HAS_ERROR=true
          wexError "Script file not found" ${WEX_SCRIPT_FILE}
        fi
      fi;
      exit
    fi;

    # Include loaded file
    . "${WEX_SCRIPT_FILE}"

    # Init empty var.
    _ARGUMENTS=()
    _DESCRIPTION=false
    # Catch arguments
    ARGS_METHOD=${WEX_SCRIPT_METHOD_NAME}"Args";

    # Execute arguments method
    if [[ $(type -t "${ARGS_METHOD}" 2>/dev/null) == function ]]; then
      # Execute command
      ${ARGS_METHOD}
    fi;

    # We don't use getopts method in order to support long and short notations
    # Add extra parameters at end of array
    _ARGUMENTS+=(
      'non_interactive non_i "Non interactive mode, use default value in place to ask user\n\t\tIf an argument is missing to not automatically ask for it, but exit." false'
      'help help "Display this help manual" false'
      'debug debug "Show extra debug information, depending of method features" false'
      'source source "Show script source instead to execute it" false'
    )
    # Then start in negative value (length of previous table).
    _NEGATIVE_ARGS_LENGTH=4
    # We iterate first on system extra parameters
    # Using negative values allow to use clean push method on array.
    for ((i=-${_NEGATIVE_ARGS_LENGTH}; i < ${#_ARGUMENTS[@]}-${_NEGATIVE_ARGS_LENGTH}; i++)); do
      eval "PARAMS=(${_ARGUMENTS[${i}]})"
      ARG_EXPECTED_LONG=${PARAMS[0]}
      ARG_EXPECTED_SHORT=${PARAMS[1]}
      # Mark variable as empty
      local ${ARG_EXPECTED_LONG^^}=
      # Set it as null.
      eval 'unset '${ARG_EXPECTED_LONG^^}

      WEX_ARG_FOUND=false

      # Get args given,
      # ignore first one which is always method name.
      ARG_SEARCH=0;
      ORIGINAL_ARGS=("${@:2}");
      for ARG_GIVEN in "${ORIGINAL_ARGS}"
      do
        ARG_GIVEN_NAME=$(sed -e 's/-\{1,2\}\([^\=]\{0,\}\)\=.\{0,\}/\1/' <<< ${ARG_GIVEN})
        ARG_GIVEN_VALUE=${ARG_GIVEN#*\=}

        if [[ ${ARG_GIVEN_NAME} == ${ARG_EXPECTED_LONG} || ${ARG_GIVEN_NAME} == ${ARG_EXPECTED_SHORT} ]]; then
          WEX_ARG_FOUND=true
          local ${ARG_EXPECTED_LONG^^}="${ARG_GIVEN_VALUE}"
        # Support --noEqualSign -nes
        # Support also space separator.
        elif [[ "--"${ARG_EXPECTED_LONG} == ${ARG_GIVEN} || "-"${ARG_EXPECTED_SHORT} == ${ARG_GIVEN} ]]; then
          WEX_ARG_FOUND=true
          ARG_SEARCH_NEXT=$((${ARG_SEARCH}+1));
          ARG_NEXT_VALUE=${ORIGINAL_ARGS[${ARG_SEARCH_NEXT}]};

          # Use next arguments as value if exits
          if [ "${ARG_NEXT_VALUE}" != "" ] && [[ $(echo "${ARG_NEXT_VALUE}" | head -c 1) != "-" ]];then
            local ${ARG_EXPECTED_LONG^^}="${ARG_NEXT_VALUE}"
            # Ignore next parsing.
            ARG_SEARCH=ARG_SEARCH_NEXT;
          else
            local ${ARG_EXPECTED_LONG^^}=true
          fi
        fi

        ((ARG_SEARCH++))
      done;

      # If an argument is not found
      # And we are not on help page.
      if [ ${WEX_ARG_FOUND} == false ] && [ -z ${HELP+x} ] && [ -z ${SOURCE+x} ];then
        # Expected
        if [[ ${PARAMS[3]} == true ]]; then
          # Interactive mode allowed.
          if [ -z ${NON_INTERACTIVE+x} ] || [ ${NON_INTERACTIVE} == false ]; then
            echo -n ${PARAMS[2]}": "
            read ${ARG_EXPECTED_LONG^^}
          else
            wexError "Expected argument not found" "${WEX_SCRIPT_METHOD_NAME} : "${ARG_EXPECTED_LONG}
            # Raise an error.
            # Unable to fetch expected variable
            exit 0
          fi;
        fi;
      fi;
    done

    # Show help manual
    if [ ! -z ${HELP+x} ]; then
      . ${WEX_DIR_BASH}/colors.sh

      echo ""
      printf '.%.0s' {1..60}
      printf "\n"

      printf "${WEX_COLOR_CYAN}Name${WEX_COLOR_RESET}\t\t${WEX_SCRIPT_CALL_NAME}\n"
      printf "${WEX_COLOR_CYAN}Function${WEX_COLOR_RESET}\t${WEX_SCRIPT_METHOD_NAME}\n"
      printf "${WEX_COLOR_CYAN}File${WEX_COLOR_RESET}\t\t${WEX_SCRIPT_FILE}\n"

      if [ "${_DESCRIPTION}" != "false" ]; then
        echo ""
        printf "${WEX_COLOR_CYAN}Description${WEX_COLOR_RESET}\n"
        echo ${_DESCRIPTION} | fold -w 60
      fi

      echo ""
      printf "${WEX_COLOR_CYAN}Arguments${WEX_COLOR_RESET}\n"

      for ((i=-${_NEGATIVE_ARGS_LENGTH}; i < ${#_ARGUMENTS[@]}-${_NEGATIVE_ARGS_LENGTH}; i++)); do
        eval "PARAMS=(${_ARGUMENTS[${i}]})"
        ARG_EXPECTED_LONG=${PARAMS[0]}

        TEXT=$(wex text/color -c=lightblue -t="--${PARAMS[0]} -${PARAMS[1]}")

        if [ ${PARAMS[3]} == true ]; then
          TEXT+="\n\t"$(wex text/color -c=brown -t=\(require\)' ')
        fi;

        TEXT+="\n\t\t"${PARAMS[2]}
        TEXT+="\n"

        echo -e ${TEXT}
      done;

      printf '.%.0s' {1..60}
      echo ""
      echo ""

    # Display script file source.
    elif [ ! -z ${SOURCE+x} ]; then
      cat ${WEX_SCRIPT_FILE}
      echo ""

    # Execute script.
    else
      # Execute function with all parameters.
      eval ${WEX_SCRIPT_METHOD_NAME} "${@:2}"
    fi;
  }
fi;

# Execute function with same arguments.
wex "${@}"

