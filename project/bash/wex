#!/usr/bin/env bash

# Init only once.
if [ "$(type -t wex)" != "function" ];then
  . /opt/wex/project/includes/globals.sh

  wex() {
    # Running unit test.
    if [ "${1}" = "test" ];then
      bash "${WEX_DIR_BASH}test.sh" "${2}"
      exit;
    fi

    local WEX_SCRIPT_FILE
    local WEX_SCRIPT_METHOD_NAME
    local WEX_SCRIPT_METHOD_ARGS_NAME

    WEX_SCRIPT_CALL_NAME="${1}"
    WEX_SCRIPT_FILE=$(_wexFindScriptFile "${WEX_SCRIPT_CALL_NAME}")

    # File does not exists.
    if [ ! -f "${WEX_SCRIPT_FILE}" ]; then
      return
    fi

    WEX_SCRIPT_METHOD_NAME=$(_wexMethodName "${WEX_SCRIPT_CALL_NAME}")

    # Include found script file
    . "${WEX_SCRIPT_FILE}"
    # Disable space as array item separator

    local WEX_CALLING_ARGUMENTS=()
    _wexGetArguments "${WEX_SCRIPT_CALL_NAME}"

    # Then start in negative value (length of previous table).
    local _NEGATIVE_ARGS_LENGTH="${#WEX_ARGUMENT_DEFAULTS[@]}"
    # We iterate first on system extra parameters
    # Using negative values allow to use clean push method on array.
    for ((i=-_NEGATIVE_ARGS_LENGTH; i < ${#WEX_CALLING_ARGUMENTS[@]}-_NEGATIVE_ARGS_LENGTH; i++)); do
      local WEX_ARG_FOUND=false
      eval "PARAMS=(${WEX_CALLING_ARGUMENTS[${i}]})"
      local ARG_EXPECTED_LONG=${PARAMS[0]}
      local ARG_EXPECTED_SHORT=${PARAMS[1]}
      # Mark variable as empty
      local ${ARG_EXPECTED_LONG^^}=
      # Set it as null.
      eval 'unset '${ARG_EXPECTED_LONG^^}

      # Get args given,
      # ignore first one which is always method name.
      local ARG_SEARCH=0;
      local ORIGINAL_ARGS=("${@:2}");

      for ARG_GIVEN in "${ORIGINAL_ARGS[@]}"
      do
        ARG_GIVEN_NAME=$(sed -e 's/-\{1,2\}\([^\=]\{0,\}\)\=.\{0,\}/\1/' <<< ${ARG_GIVEN})
        ARG_GIVEN_VALUE=${ARG_GIVEN#*\=}

        if [ "${ARG_GIVEN_NAME}" = "${ARG_EXPECTED_LONG}" ] || [ "${ARG_GIVEN_NAME}" = "${ARG_EXPECTED_SHORT}" ]; then
          WEX_ARG_FOUND=true
          local ${ARG_EXPECTED_LONG^^}="${ARG_GIVEN_VALUE}"
        # Support --noEqualSign -nes
        # Support also space separator.
        elif [ "--${ARG_EXPECTED_LONG}" = "${ARG_GIVEN}" ] || [ "-${ARG_EXPECTED_SHORT}" = "${ARG_GIVEN}" ]; then
          WEX_ARG_FOUND=true
          ARG_SEARCH_NEXT=$((${ARG_SEARCH}+1));
          ARG_NEXT_VALUE=${ORIGINAL_ARGS[${ARG_SEARCH_NEXT}]};

          # Use next arguments as value if exits
          if [ "${ARG_NEXT_VALUE}" != "" ] && [ "$(echo "${ARG_NEXT_VALUE}" | head -c 1)" != "-" ];then
            local ${ARG_EXPECTED_LONG^^}="${ARG_NEXT_VALUE}"
            # Ignore next parsing.
            ARG_SEARCH=ARG_SEARCH_NEXT;
          else
            local ${ARG_EXPECTED_LONG^^}=true
          fi
        fi

        ((ARG_SEARCH++))
      done;

      # If an argument is not found
      # And we are not on help page.
      if [ "${WEX_ARG_FOUND}" = "false" ] && [ -z ${HELP+x} ] && [ -z ${SOURCE+x} ];then
        # A default value is set in arguments list.
        if [ "${PARAMS[4]}" != "" ];then
          local ${ARG_EXPECTED_LONG^^}="${PARAMS[4]}"
        # Expected
        elif [ "${PARAMS[3]}" = "true" ]; then
          echo "${WEX_SCRIPT_FILE}"
          # Interactive mode allowed.
          if [ -z ${NON_INTERACTIVE+x} ] || [ "${NON_INTERACTIVE}" = "false" ]; then
            echo -n ${PARAMS[2]}": "
            read ${ARG_EXPECTED_LONG^^}
          else
            _wexError "Expected argument not found" "${WEX_SCRIPT_METHOD_NAME} : "${ARG_EXPECTED_LONG}
            # Raise an error.
            # Unable to fetch expected variable
            exit 0
          fi;
        fi;
      fi;
    done

    # Show help manual
    if [ ! -z ${HELP+x} ]; then
      . "${WEX_DIR_ROOT}includes/colors.sh"

      echo ""
      printf '.%.0s' {1..60}
      printf "\n"

      printf "${WEX_COLOR_CYAN}Name${WEX_COLOR_RESET}\t\t${WEX_SCRIPT_CALL_NAME}\n"
      printf "${WEX_COLOR_CYAN}Function${WEX_COLOR_RESET}\t${WEX_SCRIPT_METHOD_NAME}\n"
      printf "${WEX_COLOR_CYAN}File${WEX_COLOR_RESET}\t\t${WEX_SCRIPT_FILE}\n"
      printf "${WEX_COLOR_CYAN}Requirements${WEX_COLOR_RESET}\t${_REQUIREMENTS[*]}\n"

      if [ "${_DESCRIPTION}" != "false" ]; then
        echo ""
        printf "${WEX_COLOR_CYAN}Description${WEX_COLOR_RESET}\n"
        echo "${_DESCRIPTION}" | fold -w 60
      fi

    # Display script file source.
    elif [ ! -z ${SOURCE+x} ]; then
      . ${WEX_DIR_BASH}/colors.sh
      printf ${WEX_COLOR_LIGHT_CYAN}
      cat ${WEX_SCRIPT_FILE}
      printf ${WEX_COLOR_RESET}"\n"

    # Execute script.
    else
      # Execute function with all parameters.
      ${WEX_SCRIPT_METHOD_NAME} "${@:2}"
    fi
  }
fi;

# Execute function with same arguments.
wex "${@}"